{"version":3,"sources":["webpack:///../../src/layouts/shared/SizeCache.ts","webpack:///../../src/layouts/shared/BaseLayout.ts","webpack:///../src/layouts/flow.ts"],"names":["SizeCache","config","_classCallCheck","_map","Map","_roundAverageSize","totalSize","roundAverageSize","this","_createClass","key","value","index","prev","get","set","size","average","Math","round","clear","dim1","direction","BaseLayout","hostSink","_this","_latestCoords","left","top","_direction","_viewportSize","width","height","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_firstVisible","_lastVisible","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_items","_scrollSize","_overhang","_hostSink","Promise","resolve","then","_getDefaultConfig","Object","assign","items","_setItems","_scheduleReflow","dir","_triggerReflow","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","coords","oldPos","change","abs","force","arguments","length","undefined","_reflow","_this$_pin","block","max","min","options","val","_sendUnpinnedMessage","_this2","reflowIfNeeded","_updateLayout","_updateScrollSize","_setPositionFromPin","_getActiveItems","_updateVisibleIndices","_sendStateChangedMessage","pin","lastScrollPosition","_this$pin","_calculateScrollIntoViewPosition","itemStartPosition","_getItemPosition","scrollPosition","itemSize","_getItemSize","itemEndPosition","currentScrollPosition","_clampScrollPosition","_defineProperty","type","firstVisible","lastVisible","childPositions","idx","message","scrollSize","range","first","last","scrollError","_num","emit","_sendVisibilityChangedMessage","flow","FlowLayout","leadingMargin","trailingMargin","offset","collapseMargins","a","b","m","sort","apply","_toConsumableArray","MetricsCache","_childSizeCache","_marginSizeCache","_metricsCache","metrics","marginsToUpdate","Set","keys","forEach","k","Number","add","_step","_iterator","_createForOfIteratorHelper","s","n","done","_this$_metricsCache$g","_this$_metricsCache$g2","err","e","f","averageSize","_this$_metricsCache$g3","getSize","_BaseLayout","_itemSize","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","_inherits","sizes","update","_this$_newPhysicalIte","item","_getPhysicalItem","getChildSize","averageChildSize","c","averageMarginSize","_getAverageSize","delta","refItem","pos","getMarginSize","_this$_metricsCache$g4","_estimatePosition","lower","upper","floor","_delta","_calculateAnchor","firstItem","lastItem","firstMin","lastMin","lastMax","candidateIdx","cMax","Infinity","candidate","_clearItems","_getItems","_this$_metricsCache$g5","_this$_metricsCache$g6","_getPosition","_getAnchor","anchorSize","_getSize","anchorLeadingMargin","anchorTrailingMargin","anchorErr","margin","extentErr","_calculateError","_superPropGet","_resetReflowState","_this$_metricsCache$g7","getLeadingMarginValue"],"mappings":"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","file":"js/chunk-2d0c849e.0b5c8ac7.js","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport interface SizeCacheConfig {\n  roundAverageSize?: boolean;\n}\n\nexport class SizeCache {\n  private _map = new Map<number | string, number>();\n  private _roundAverageSize = false;\n  totalSize = 0;\n\n  constructor(config?: SizeCacheConfig) {\n    if (config?.roundAverageSize === true) {\n      this._roundAverageSize = true;\n    }\n  }\n\n  set(index: number | string, value: number): void {\n    const prev = this._map.get(index) || 0;\n    this._map.set(index, value);\n    this.totalSize += value - prev;\n  }\n\n  get averageSize(): number {\n    if (this._map.size > 0) {\n      const average = this.totalSize / this._map.size;\n      return this._roundAverageSize ? Math.round(average) : average;\n    }\n    return 0;\n  }\n\n  getSize(index: number | string) {\n    return this._map.get(index);\n  }\n\n  clear() {\n    this._map.clear();\n    this.totalSize = 0;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  Layout,\n  ChildPositions,\n  Positions,\n  ScrollDirection,\n  Size,\n  dimension,\n  position,\n  PinOptions,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  StateChangedMessage,\n  LayoutHostSink,\n} from './Layout.js';\n\ntype UpdateVisibleIndicesOptions = {\n  emit?: boolean;\n};\n\nexport function dim1(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\n\nexport function dim2(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\n\nexport function pos1(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\n\nexport function pos2(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\n\nexport abstract class BaseLayout<C extends BaseLayoutConfig> implements Layout {\n  /**\n   * The last set viewport scroll position.\n   */\n  private _latestCoords: Positions = {left: 0, top: 0};\n\n  /**\n   * Scrolling direction.\n   */\n  private _direction: ScrollDirection | null = null;\n\n  /**\n   * Dimensions of the viewport.\n   */\n  private _viewportSize: Size = {width: 0, height: 0};\n\n  public totalScrollSize: Size = {width: 0, height: 0};\n\n  public offsetWithinScroller: Positions = {left: 0, top: 0};\n\n  /**\n   * Flag for debouncing asynchronous reflow requests.\n   */\n  private _pendingReflow = false;\n\n  private _pendingLayoutUpdate = false;\n\n  protected _pin: PinOptions | null = null;\n\n  /**\n   * The index of the first item intersecting the viewport.\n   */\n  protected _firstVisible = 0;\n\n  /**\n   * The index of the last item intersecting the viewport.\n   */\n  protected _lastVisible = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the first child.\n   */\n  protected _physicalMin = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the last child.\n   */\n  protected _physicalMax = 0;\n\n  /**\n   * Index of the first child.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child.\n   */\n  protected _last = -1;\n\n  /**\n   * Length in the scrolling direction.\n   */\n  protected _sizeDim: dimension = 'height';\n\n  /**\n   * Length in the non-scrolling direction.\n   */\n  protected _secondarySizeDim: dimension = 'width';\n\n  /**\n   * Position in the scrolling direction.\n   */\n  protected _positionDim: position = 'top';\n\n  /**\n   * Position in the non-scrolling direction.\n   */\n  protected _secondaryPositionDim: position = 'left';\n\n  /**\n   * Current scroll offset in pixels.\n   */\n  protected _scrollPosition = 0;\n\n  /**\n   * Difference between current scroll offset and scroll offset calculated due\n   * to a reflow.\n   */\n  protected _scrollError = 0;\n\n  /**\n   * Total number of items that could possibly be displayed. Used to help\n   * calculate the scroll size.\n   */\n  protected _items: unknown[] = [];\n\n  /**\n   * The total (estimated) length of all items in the scrolling direction.\n   */\n  protected _scrollSize = 1;\n\n  /**\n   * Number of pixels beyond the viewport to still include\n   * in the active range of items.\n   */\n  // TODO (graynorton): Probably want to make this something we calculate based\n  // on viewport size, item size, other factors, possibly still with a dial of some kind\n  protected _overhang = 1000;\n\n  /**\n   * Call this to deliver messages (e.g. stateChanged, unpinned) to host\n   */\n  private _hostSink: LayoutHostSink;\n\n  protected _getDefaultConfig(): C {\n    return {\n      direction: 'vertical',\n    } as C;\n  }\n\n  constructor(hostSink: LayoutHostSink, config?: C) {\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(\n      () => (this.config = config || this._getDefaultConfig())\n    );\n  }\n\n  set config(config: C) {\n    Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n  }\n\n  get config(): C {\n    return {\n      direction: this.direction,\n    } as C;\n  }\n\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items(): unknown[] {\n    return this._items;\n  }\n\n  set items(items: unknown[]) {\n    this._setItems(items);\n  }\n\n  protected _setItems(items: unknown[]) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n\n  /**\n   * Primary scrolling direction.\n   */\n  get direction(): ScrollDirection {\n    return this._direction!;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize(): Size {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {_viewDim1, _viewDim2} = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll(): Positions {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n\n  set pin(options: PinOptions | null) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n\n  get pin() {\n    if (this._pin !== null) {\n      const {index, block} = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block,\n      };\n    }\n    return null;\n  }\n\n  _clampScrollPosition(val: number) {\n    return Math.max(\n      -this.offsetWithinScroller[this._positionDim],\n      Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1)\n    );\n  }\n\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n\n  /**\n   * Get the top and left positioning of the item at idx.\n   */\n  protected abstract _getItemPosition(idx: number): Positions;\n\n  /**\n   * Update _first and _last based on items that should be in the current\n   * range.\n   */\n  protected abstract _getActiveItems(): void;\n\n  protected abstract _getItemSize(_idx: number): Size;\n\n  /**\n   * Calculates (precisely or by estimating, if needed) the total length of all items in\n   * the scrolling direction, including spacing, caching the value in the `_scrollSize` field.\n   *\n   * Should return a minimum value of 1 to ensure at least one item is rendered.\n   * TODO (graynorton): Possibly no longer required, but leaving here until it can be verified.\n   */\n  protected abstract _updateScrollSize(): void;\n\n  protected _updateLayout(): void {\n    // Override\n  }\n\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  protected get _viewDim1(): number {\n    return this._viewportSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _viewDim2(): number {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  protected _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  protected _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  protected _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  protected _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  protected _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {index, block} = this.pin;\n      this._scrollPosition =\n        this._calculateScrollIntoViewPosition({\n          index,\n          block: block || 'start',\n        }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  protected _calculateScrollIntoViewPosition(options: PinOptions) {\n    const {block} = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition =\n          itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition =\n            Math.abs(currentScrollPosition - itemStartPosition) <\n            Math.abs(currentScrollPosition - itemEndPosition)\n              ? itemStartPosition\n              : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n\n  public getScrollIntoViewCoordinates(\n    options: PinOptions\n  ): ScrollToCoordinates {\n    return {\n      [this._positionDim as position]:\n        this._calculateScrollIntoViewPosition(options),\n    } as ScrollToOptions;\n  }\n\n  private _sendUnpinnedMessage() {\n    this._hostSink({\n      type: 'unpinned',\n    });\n  }\n\n  private _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: 'visibilityChanged',\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible,\n    });\n  }\n\n  protected _sendStateChangedMessage() {\n    const childPositions: ChildPositions = new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message: StateChangedMessage = {\n      type: 'stateChanged',\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null,\n      } as Size,\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible,\n      },\n      childPositions,\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0,\n      } as Positions;\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n\n  /**\n   * Number of items to display.\n   */\n  private get _num(): number {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n\n  private _checkThresholds() {\n    if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(\n        this._scrollSize,\n        this._scrollPosition + this._viewDim1 + this._overhang\n      );\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({emit: true});\n      }\n    }\n  }\n\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  protected _updateVisibleIndices(options?: UpdateVisibleIndicesOptions) {\n    if (this._first === -1 || this._last === -1) return;\n\n    let firstVisible = this._first;\n    while (\n      firstVisible < this._last &&\n      Math.round(\n        this._getItemPosition(firstVisible)[this._positionDim] +\n          this._getItemSize(firstVisible)[this._sizeDim]\n      ) <= Math.round(this._scrollPosition)\n    ) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n    while (\n      lastVisible > this._first &&\n      Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n        Math.round(this._scrollPosition + this._viewDim1)\n    ) {\n      lastVisible--;\n    }\n\n    if (\n      firstVisible !== this._firstVisible ||\n      lastVisible !== this._lastVisible\n    ) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {SizeCache} from './shared/SizeCache.js';\nimport {BaseLayout, dim1} from './shared/BaseLayout.js';\nimport {\n  Positions,\n  Size,\n  Margins,\n  margin,\n  ScrollDirection,\n  offsetAxis,\n  ChildMeasurements,\n  BaseLayoutConfig,\n  LayoutHostSink,\n} from './shared/Layout.js';\n\ntype ItemBounds = {\n  pos: number;\n  size: number;\n};\n\ntype FlowLayoutConstructor = {\n  prototype: FlowLayout;\n  new (hostSink: LayoutHostSink, config?: BaseLayoutConfig): FlowLayout;\n};\n\ntype FlowLayoutSpecifier = BaseLayoutConfig & {\n  type: FlowLayoutConstructor;\n};\n\ntype FlowLayoutSpecifierFactory = (\n  config?: BaseLayoutConfig\n) => FlowLayoutSpecifier;\n\nexport const flow: FlowLayoutSpecifierFactory = (config?: BaseLayoutConfig) =>\n  Object.assign(\n    {\n      type: FlowLayout,\n    },\n    config\n  );\n\nfunction leadingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\n\nfunction trailingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\n\nfunction offset(direction: ScrollDirection): offsetAxis {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\n\nfunction collapseMargins(a: number, b: number): number {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\n\nclass MetricsCache {\n  private _childSizeCache = new SizeCache();\n  private _marginSizeCache = new SizeCache();\n  private _metricsCache = new Map<number, Size & Margins>();\n\n  update(metrics: {[key: number]: Size & Margins}, direction: ScrollDirection) {\n    const marginsToUpdate = new Set<number>();\n    Object.keys(metrics).forEach((key) => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n      const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n\n  get averageChildSize(): number {\n    return this._childSizeCache.averageSize;\n  }\n\n  get totalChildSize(): number {\n    return this._childSizeCache.totalSize;\n  }\n\n  get averageMarginSize(): number {\n    return this._marginSizeCache.averageSize;\n  }\n\n  get totalMarginSize(): number {\n    return this._marginSizeCache.totalSize;\n  }\n\n  getLeadingMarginValue(index: number, direction: ScrollDirection) {\n    return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n  }\n\n  getChildSize(index: number) {\n    return this._childSizeCache.getSize(index);\n  }\n\n  getMarginSize(index: number) {\n    return this._marginSizeCache.getSize(index);\n  }\n\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\n\nexport class FlowLayout extends BaseLayout<BaseLayoutConfig> {\n  /**\n   * Initial estimate of item size\n   */\n  _itemSize: Size = {width: 100, height: 100};\n\n  /**\n   * Indices of children mapped to their (position and length) in the scrolling\n   * direction. Used to keep track of children that are in range.\n   */\n  _physicalItems = new Map<number, ItemBounds>();\n\n  /**\n   * Used in tandem with _physicalItems to track children in range across\n   * reflows.\n   */\n  _newPhysicalItems = new Map<number, ItemBounds>();\n\n  /**\n   * Width and height of children by their index.\n   */\n  _metricsCache = new MetricsCache();\n\n  /**\n   * anchorIdx is the anchor around which we reflow. It is designed to allow\n   * jumping to any point of the scroll size. We choose it once and stick with\n   * it until stable. _first and _last are deduced around it.\n   */\n  _anchorIdx: number | null = null;\n\n  /**\n   * Position in the scrolling direction of the anchor child.\n   */\n  _anchorPos: number | null = null;\n\n  /**\n   * Whether all children in range were in range during the previous reflow.\n   */\n  _stable = true;\n\n  private _measureChildren = true;\n\n  _estimate = true;\n\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n\n  // })\n\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n\n  get measureChildren() {\n    return this._measureChildren;\n  }\n\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes: ChildMeasurements) {\n    this._metricsCache.update(sizes as Size & Margins, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n\n  _getPhysicalItem(idx: number): ItemBounds | undefined {\n    return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n  }\n\n  _getSize(idx: number): number | undefined {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n\n  _getAverageSize(): number {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n\n  _estimatePosition(idx: number): number {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return (\n        c.averageMarginSize +\n        idx * (c.averageMarginSize + this._getAverageSize())\n      );\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return (\n          refItem!.pos -\n          (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n          (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize)\n        );\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return (\n          refItem!.pos +\n          (c.getChildSize(this._last) || c.averageChildSize) +\n          (c.getMarginSize(this._last) || c.averageMarginSize) +\n          delta * (c.averageChildSize + c.averageMarginSize)\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx: number): number {\n    const item = this._getPhysicalItem(idx);\n    const {averageMarginSize} = this._metricsCache;\n    return idx === 0\n      ? this._metricsCache.getMarginSize(0) ?? averageMarginSize\n      : item\n      ? item.pos\n      : this._estimatePosition(idx);\n  }\n\n  _calculateAnchor(lower: number, upper: number): number {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(\n      0,\n      Math.min(\n        this.items.length - 1,\n        Math.floor((lower + upper) / 2 / this._delta)\n      )\n    );\n  }\n\n  _getAnchor(lower: number, upper: number): number {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem!.pos,\n      lastMin = lastItem!.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last)!;\n\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate!.pos + this._metricsCache.getChildSize(candidateIdx)!;\n    }\n    return candidateIdx;\n  }\n\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {index} = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n\n    const anchorLeadingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx) ??\n      this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx + 1) ??\n      this._metricsCache.averageMarginSize;\n\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n\n    items.set(this._anchorIdx, {pos: this._anchorPos, size: anchorSize});\n\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {pos, size});\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {pos, size});\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach((item) => (item.pos -= extentErr));\n      this._scrollError += extentErr;\n    }\n\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n\n  _calculateError(): number {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return (\n        this._physicalMax -\n        this._scrollSize +\n        (this.items.length - 1 - this._last) * this._delta\n      );\n    }\n    return 0;\n  }\n\n  override _reflow() {\n    const {_first, _last} = this;\n    super._reflow();\n    if (\n      (this._first === -1 && this._last == -1) ||\n      (this._first === _first && this._last === _last)\n    ) {\n      this._resetReflowState();\n    }\n  }\n\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n\n  _updateScrollSize() {\n    const {averageMarginSize} = this._metricsCache;\n    this._scrollSize = Math.max(\n      1,\n      this.items.length * (averageMarginSize + this._getAverageSize()) +\n        averageMarginSize\n    );\n  }\n\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  protected get _delta(): number {\n    const {averageMarginSize} = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx: number): Positions {\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -(\n        this._metricsCache.getLeadingMarginValue(idx, this.direction) ??\n        this._metricsCache.averageMarginSize\n      ),\n    } as Positions;\n  }\n\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx: number): Size {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n    } as Size;\n  }\n\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}\n"],"sourceRoot":""}